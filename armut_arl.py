#########################
# BUSINESS PROBLEM
#########################


# Armut, Turkey's largest online service platform, brings together service providers and those who want to receive service.
# Using the data set containing the users receiving service and the services and categories they received
# It is desired to create a product recommendation system with Association Rule Learning.

# 1. Data Preprocessing
# 2: Extract Association Rules and Recommend Service.


#########################
# Dataset
#########################

# The data set consists of the services received by customers and the categories of these services.
# Contains date and time information of each service received.

# UserId: Customer number
# ServiceId: Anonymized services belonging to each category. (Example: Sofa washing service under the cleaning category)
#    A ServiceId can be found under different categories and represents different services under different categories.
#    (Example: The service with CategoryId 7 and ServiceId 4 is radiator cleaning, while the service with CategoryId 2 and ServiceId 4 is furniture assembly)
# CategoryId: These are anonymized categories. (Example: Cleaning, transportation, renovation category)
# CreateDate: Date the service was purchased

import pandas as pd
from mlxtend.frequent_patterns import apriori, association_rules

pd.set_option('display.max_columns', None)
pd.set_option('display.width', 500)
pd.set_option('display.expand_frame_repr', False)


#############################
#### 1. Data Preprocessing
#############################

## 1.1: Read 'armut_data.csv' file.

df_ = pd.read_csv("datasets/armut_data.csv")
df = df_.copy()
df.head()


## 1.2: Create a new variable to represent these services by combining ServiceId (row[1]) and CategoryId (row[2]) with "_".
#       ServiceID represents a different service for each CategoryID.

# using list comprehension the column is generated by concatenating the second and third elements of each row with an underscore _ in between.

df["Service"] = [str(row[1]) + '_' + str(row[2]) for row in df.values]
df.head()


## 1.3: Combine UserId and the date variable you just created as 'YYYY_MM' and assign it to a new variable called BasketId.

# The data set consists of the date and time the services were received, there is no basket definition (invoice, etc.).
# In order to apply Association Rule Learning, a basket (invoice, etc.) definition must be created.
# Here, the basket definition is the services (CategoryId_ServiceId) that each customer receives monthly.
# Baskets must be identified with a unique ID. -- "BasketId"
# To do this, first create a new date variable that contains only the year and month. -- "CreateDate"
# Combine UserID and the date variable you just created with "_" and assign it to a new variable called BasketId.

# check DType of columns.
df.info()
df.head()

# convert 'CreateDate' type to datetime.
df["CreateDate"] = pd.to_datetime(df["CreateDate"])

# create new variable showing service's year and month info as YYYY_MM. - fifth column.
df["Year_Month"] = df["CreateDate"].dt.strftime("%Y-%m")

# create "BasketID" in the form 'userID_Year_Month'
# row[0]: userID, row[5]: Year_Month
df["BasketId"] = [str(row[0]) + '_' + str(row[5]) for row in df.values]


#    UserId  ServiceId  CategoryId          CreateDate Service Year_Month       BasketId
# 0   25446          4           5 2017-08-06 16:11:00     4_5    2017-08  25446_2017-08
# 1   22948         48           5 2017-08-06 16:12:00    48_5    2017-08  22948_2017-08




#############################
#### 2: Extract Association Rules and Recommend Service.
#############################

## 2.1: Create pivot table of "BasketId" and "Service" as shown below.

# Service        0_8  10_9  11_11  12_7  13_11  14_7  15_1  16_8  17_5  18_4..
# BasketId
# 0_2017-08        0     0      0     0      0     0     0     0     0     0..
# 0_2017-09        0     0      0     0      0     0     0     0     0     0..
# 0_2018-01        0     0      0     0      0     0     0     0     0     0..
# 0_2018-04        0     0      0     0      0     1     0     0     0     0..
# 10000_2017-08    0     0      0     0      0     0     0     0     0     0..


# Count 'Service' for each 'BasketId'. Then represent counts as binary using applymap.
# If count is greater than zero change to 1. If count equals to zero change to zero.

invoice_product_df = df.groupby(['BasketId', 'Service'])['Service'].count().unstack().fillna(0).applymap(lambda x: 1 if x > 0 else 0)
invoice_product_df.head()

# [71220 rows x 50 columns]

invoice_product_df_bool = df.groupby(['BasketId', 'Service'])['Service'].count().unstack().fillna(0).applymap(lambda x: True if x > 0 else False)


## 2.2 : Create association rules.

frequent_itemsets = apriori(invoice_product_df_bool, min_support=0.01, use_colnames=True)
rules = association_rules(frequent_itemsets, metric="support", min_threshold=0.01)


## 2.3 : Use the "arl_recommender" function to recommend 3 services to a user who last received the 2_0 service.

def arl_recommender_metric(rules_df, product_id, metric, rec_count=1):
    '''
    parameters:
        rules_df: association rules dataframe.
        product_id: id of the product that is in the basket to be used for recommendations.
        metric: metric for sorting the itemsets in rules_df.
        rec_count: number of recommended products.
    '''
    # sort rules according to specified metric in descending order
    sorted_rules = rules_df.sort_values(metric, ascending=False)
    recommendation_list = []
    # i: index, product: values of the column antecedents(X)
    for i, product in enumerate(sorted_rules["antecedents"]):
        # j: each product in product set (itemset)
        for j in list(product):
            # consider antecedents(X) with 'product_id'.
            # if the product of interest (product_id) equals to 'product' from an antecedent(X)
            if j == product_id:
                # select first product of corresponding consequent(Y) for product_id in the antecedent of an index i
                recommendation_list.append(list(sorted_rules.iloc[i]["consequents"])[0])

    return recommendation_list[0:rec_count]

# list of recommended services.
recommended_services=arl_recommender(rules, "2_0", rec_count=3)

print(recommended_services)
